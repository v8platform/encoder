package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_starlark.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	f := newFileInfo(file)

	g.P("// Code generated by protoc-gen-starlark-go. DO NOT EDIT.")
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(gen, g, f, imps.Get(i))
	}

	for _, message := range f.allMessages {
		genMessage(gen, g, f, message)
	}

	return g
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

func genMessage(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, m *messageInfo) {
	if m.Desc.IsMapEntry() {
		return
	}

	// Message type declaration.
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("type ", StarlarkStructName(m.GoIdent), ` struct{`)
	genMessageFields(gen, g, f, m)
	g.P("}")
	g.P()

	genStarlarkProvider(g, m)
	genConverter(g, m)
}

func genMessageFields(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, m *messageInfo) {
	sf := f.allMessageFieldsByPtr[m]
	for _, field := range m.Fields {
		genMessageField(gen, g, f, m, field, sf)
	}
}

func genMessageField(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, m *messageInfo, field *protogen.Field, sf *structFields) {
	if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
		if oneof.Fields[0] == field {
			g.P(StarlarkFieldName(oneof.GoIdent, oneof.GoName).GoName, " ", g.QualifiedGoIdent(starlarkValue))
		}
	}

	g.P(StarlarkFieldName(field.GoIdent, field.GoName).GoName, " ", fieldStarlarkType(gen, g, f, field))
}

// fieldStarlarkType returns the Starlark type used for a field.
func fieldStarlarkType(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, field *protogen.Field) string {
	switch {
	case field.Desc.IsList():
		// TODO Enhance it
		return `*` + g.QualifiedGoIdent(starlarkList)
	case field.Desc.IsMap():
		return `*` + g.QualifiedGoIdent(starlarkMap)
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return g.QualifiedGoIdent(starlarkBool)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Uint32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return g.QualifiedGoIdent(starlarkInt)
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return g.QualifiedGoIdent(starlarkFloat)
	case protoreflect.StringKind:
		return g.QualifiedGoIdent(starlarkString)
	case protoreflect.BytesKind:
		return g.QualifiedGoIdent(starlarkBytes)
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(starlarkString)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		full := string(field.Message.Desc.FullName())
		if custom := CustomMap[full]; custom != nil {
			name, pointer := custom.Name()
			prefix := ""
			if pointer {
				prefix = "*"
			}
			return prefix + g.QualifiedGoIdent(name)
		}
		if ext := GetMessageExtensionFor(field.Message.Desc); ext != nil {
			switch {
			case ext.GetDisable():
				return ""
			case ext.GetToString():
				return g.QualifiedGoIdent(starlarkString)
			}

			if custom := ext.GetCustom(); custom != nil {
				importPath := GetImportPath(custom.GetStarlarkTypePackage(), field.Message.GoIdent.GoImportPath)
				importName := custom.GetStarlarkTypeName()
				prefix := ""
				if strings.HasPrefix(importName, "*") {
					prefix = "*"
					importName = importName[1:]
				}
				return prefix + g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: importPath, GoName: importName})
			}

			gen.Error(fmt.Errorf("invalid option"))
			return ""
		}
		if IsWellKnownType(full) {
			_, _ = os.Stderr.WriteString("unsupported well-known type " + full + "\n")
			//gen.Error(fmt.Errorf("unsupported well-known type %s", full))
			return g.QualifiedGoIdent(starlarkValue)
		}

		return `*` + g.QualifiedGoIdent(StarlarkStructName(field.Message.GoIdent))
	}

	gen.Error(fmt.Errorf("unknown type (not supported)"))
	return ""
}

func genStarlarkProvider(g *protogen.GeneratedFile, m *messageInfo) {
	g.P(`var _ `, g.QualifiedGoIdent(starlarkValue), ` = (*`, StarlarkStructName(m.GoIdent), `)(nil)`)
	g.P(`var _ `, g.QualifiedGoIdent(starlarkHasAttrs), ` = (*`, StarlarkStructName(m.GoIdent), `)(nil)`)

	// String() string
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") String() string {")
	g.P(`if x == nil { return "`, m.Desc.Name(), `{}" }`)
	g.P(`return `, g.QualifiedGoIdent(fmtSprintf), `("`, m.Desc.Name(), `{"+`)
	for i, field := range m.Fields {
		prefix := ""
		if i != 0 {
			prefix = ", "
		}
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			g.P(`"`, prefix, oneof.Desc.Name(), `= %s"+`)
		}

		g.P(`"`, prefix, field.Desc.JSONName(), `= %s"+`)
	}

	g.P(`"}",`)
	for _, field := range m.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			g.P(`x.`, StarlarkFieldName(oneof.GoIdent, oneof.GoName).GoName, `,`)
		}

		g.P(`x.`, StarlarkFieldName(field.GoIdent, field.GoName).GoName, `,`)
	}
	g.P(`)`)
	g.P(`}`)

	// Type() string
	// TODO: support custom type name
	g.P("func (x *", StarlarkStructName(m.GoIdent), `) Type() string { return "`, m.Desc.FullName(), `"}`)

	// Freeze()
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") Freeze() {}")

	//Truth() Bool
	// TODO: support custom truth
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") Truth() ", g.QualifiedGoIdent(starlarkBool), " { return true }")

	// Hash() (uint32, error)
	// TODO: support custom hash
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") Hash() (uint32, error) { return 0, ", g.QualifiedGoIdent(fmtErrorf), `("un-hashable") }`)

	// AttrNames() []string
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") AttrNames() []string { return []string{")
	for _, field := range m.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			g.P(`"`, oneof.Desc.Name(), `",`)
		}

		g.P(namesListQuoteAndJoinByComma(field.Desc), ",")
	}
	g.P("}}")

	// Attr(name string) (Value, error) // returns (nil, nil) if attribute not present
	g.P("func (x *", StarlarkStructName(m.GoIdent), ") Attr(name string) (", starlarkValue, ", error) {")
	g.P(`if x == nil { return nil, nil }`)
	g.P("switch name {")
	for _, field := range m.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			g.P(`case "`, oneof.Desc.Name(), `":`)
			g.P("return x.", StarlarkFieldName(oneof.GoIdent, oneof.GoName).GoName, ", nil")
		}

		g.P("case ", namesListQuoteAndJoinByComma(field.Desc), ":")
		g.P("return x.", StarlarkFieldName(field.GoIdent, field.GoName).GoName, ", nil")
	}

	g.P("default:")
	g.P("return nil, nil")
	g.P("}")
	g.P("}")
}

func genDocProvider() {

}

func genConverter(g *protogen.GeneratedFile, m *messageInfo) {
	g.P("func (x *", m.GoIdent, ") ToStarlark() *", StarlarkStructName(m.GoIdent), " {")
	g.P("if x == nil { return nil }")
	for _, field := range m.Fields {
		fieldStarlarkConverterPrepare(g, m, field)
	}
	for _, field := range m.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			oneofStarlarkConverterPrepare(g, m, oneof)
		}
	}
	g.P()
	g.P("return &", StarlarkStructName(m.GoIdent), "{")
	for _, field := range m.Fields {
		if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() && oneof.Fields[0] == field {
			g.P(StarlarkFieldName(oneof.GoIdent, oneof.GoName), ": oneof_", oneof.GoName, ",")
		}
		if c := fieldStarlarkConverter(g, m, field); c != "" {
			g.P(StarlarkFieldName(field.GoIdent, field.GoName), ": ", c, ",")
		}
	}
	g.P("}")
	g.P("}")
}

func oneofStarlarkConverterPrepare(g *protogen.GeneratedFile, m *messageInfo, oneof *protogen.Oneof) {
	g.P()
	g.P("var oneof_", oneof.GoName, " ", starlarkValue)
	for i, field := range oneof.Fields {
		prefix := "} else "
		if i == 0 {
			prefix = ""
		}

		g.P(prefix, "if v := x.Get", field.GoName, "(); v != nil {")
		g.P("oneof_", oneof.GoName, " = ", simpleStarlarkConverter(g, field.Desc, "v"))
	}
	g.P("} else {")
	g.P("oneof_", oneof.GoName, " = ", starlarkNone)
	g.P("}")
}

func fieldStarlarkConverterPrepare(g *protogen.GeneratedFile, m *messageInfo, field *protogen.Field) {
	GET := func() string {
		return "x.Get" + field.GoName + "()"
	}

	if field.Desc.IsList() {
		g.P()
		g.P("l_", field.GoName, ":= make([]", starlarkValue, `, len(`, GET(), `))`)
		g.P(`for i, x := range `, GET(), "{")
		g.P("l_", field.GoName, "[i] =", simpleStarlarkConverter(g, field.Desc, "x"))
		g.P("}")
		return
	}

	if field.Desc.IsMap() {
		g.P()
		g.P("var m_", field.GoName, "*", starlarkDict)
		g.P("if tm_", field.GoName, ":=", GET(), "; tm_", field.GoName, " != nil {")
		g.P("m_", field.GoName, " = ", starlarkNewDict, "(len(tm_", field.GoName, "))")
		g.P("for k, v := range tm_", field.GoName, "{")
		g.P("_ = m_", field.GoName, ".SetKey(",
			simpleStarlarkConverter(g, field.Desc.MapKey(), "k"), ",",
			simpleStarlarkConverter(g, field.Desc.MapValue(), "v"), ")")
		g.P("}")
		g.P("} else {")
		g.P("m_", field.GoName, " = ", starlarkNewDict, "(0)")
		g.P("}")
		return
	}
}

func fieldStarlarkConverter(g *protogen.GeneratedFile, m *messageInfo, field *protogen.Field) string {
	switch {
	case field.Desc.IsList():
		return g.QualifiedGoIdent(starlarkNewList) + "(l_" + field.GoName + ")"
	case field.Desc.IsMap():
		return "m_" + field.GoName
	}

	return simpleStarlarkConverter(g, field.Desc, "x.Get"+field.GoName+"()")
}

func simpleStarlarkConverter(g *protogen.GeneratedFile, fieldDesc protoreflect.FieldDescriptor, identifier string) string {
	F := func(s protogen.GoIdent) string {
		return g.QualifiedGoIdent(s) + "(" + identifier + ")"
	}

	switch fieldDesc.Kind() {
	case protoreflect.BoolKind:
		return F(starlarkBool)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return g.QualifiedGoIdent(starlarkMakeInt64) + "(int64(" + identifier + "))"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return g.QualifiedGoIdent(starlarkMakeUint64) + "(uint64(" + identifier + "))"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return F(starlarkFloat)
	case protoreflect.StringKind:
		return F(starlarkString)
	case protoreflect.BytesKind:
		return F(starlarkBytes)
	case protoreflect.EnumKind:
		return g.QualifiedGoIdent(starlarkString) + "(" + identifier + ".String())"
	case protoreflect.MessageKind, protoreflect.GroupKind:
		full := string(fieldDesc.Message().FullName())
		if custom := CustomMap[full]; custom != nil {
			convertFunc := custom.ConvertFunc()
			if convertFunc.GoName == "" {
				return custom.Modify(identifier)
			}
			return g.QualifiedGoIdent(convertFunc) + "(" + custom.Modify(identifier) + ")"
		}
		if ext := GetMessageExtensionFor(fieldDesc.Message()); ext != nil {
			switch {
			case ext.GetDisable():
				return ""
			case ext.GetToString():
				return g.QualifiedGoIdent(starlarkString) + "(" + identifier + ".String())"
			case ext.GetCustom() != nil:
				return identifier + ".ToStarlark()"
			}
			return "" // impossible
		}
		if IsWellKnownType(full) {
			return g.QualifiedGoIdent(starlarkString) + "(" + identifier + ".String())"
		}

		return identifier + ".ToStarlark()"
	}

	return "" // impossible
}

func namesListQuoteAndJoinByComma(fieldDesc protoreflect.FieldDescriptor) string {
	return `"` + strings.Join(namesList(fieldDesc), `", "`) + `"`
}

func namesList(fieldDesc protoreflect.FieldDescriptor) []string {
	result := make([]string, 1, 2)

	jsonName := fieldDesc.JSONName()
	result[0] = jsonName

	protoName := string(fieldDesc.Name())
	if protoName != jsonName {
		result = append(result, protoName)
	}

	return result
}
